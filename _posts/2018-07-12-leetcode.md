---
layout: post
title: LeetCode failed to record
date: 2018-07-12 10:26:24.000000000 +09:00
---

在实现[LeetCode](https://leetcode-cn.com/)的问题记录

* 两数之和
  * 在使用一次遍历，然后寻找数组中是否包含 `array.contains(tartget - nums[i])`, 再获取`complement`的索引，该索引和i不相等。代码如下:
   
```
	func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    
    for i in 0 ..< nums.count {
        let complement = target - nums[i]
        if nums.contains(complement) {
            if let index = nums.index(of: complement) {
                if index != i {
                    return [i, index]
                }
            }
        }
        
    }
    fatalError("No tow sum solution.")
}
```

提交代码的时候未能通过第20的testcase，

![结果](https://github.com/emptywalker/emptywalker.github.io/blob/master/assets/screenshot/q1-02.jpg)

根据结果提示，是在超大数组的情况下，该算法会超时，说明在使用Swift Array.contains / Array.index方法在性能在大数据下存在问题，为此去查看[文档介绍](https://opensource.apple.com/source/CF/CF-550.13/CFArray.h)
> 	•	在数组中通过一个特定的索引获取值的时间复杂度最坏是`O(log n)`，但通常应该是`O(1)`。
	•	搜索一个未知索引的对象的时间复杂度最坏是`O(n (log n))`，但一般应该是`O(n)`。
	•	插入或者删除一个对象最坏的时间复杂度是`O(n (log n))`，但经常是`O(1)`


