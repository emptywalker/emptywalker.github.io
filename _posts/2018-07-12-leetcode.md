---
layout: post
title: LeetCode failed to record
date: 2018-07-12 10:26:24.000000000 +09:00
---

在实现[LeetCode](https://leetcode-cn.com/)的问题记录

* 两数之和
  * 在使用一次遍历，然后寻找数组中是否包含 `array.contains(tartget - nums[i])`, 再获取`complement`的索引，该索引和i不相等。代码如下:
   
```
	func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    
	    for i in 0 ..< nums.count {
	        let complement = target - nums[i]
	        if nums.contains(complement) {
	            if let index = nums.index(of: complement) {
	                if index != i {
	                    return [i, index]
	                }
	            }
	        }
	        
	    }
	    fatalError("No tow sum solution.")
	}
```

提交代码的时候未能通过第20的testcase，

![结果]({{ site.url }}/assets/screenshot/q1-02.jpg)

根据结果提示，是在超大数组的情况下，该算法会超时，说明在使用Swift Array.contains / Array.index方法在性能在大数据下存在问题，为此去查看[文档介绍](https://opensource.apple.com/source/CF/CF-550.13/CFArray.h)
> Computational Complexity
	The access time for a value in the array is guaranteed to be at
	worst O(lg N) for any implementation, current and future, but will
	often be O(1) (constant time). Linear search operations similarly
	have a worst case complexity of O(N*lg N), though typically the
	bounds will be tighter, and so on. Insertion or deletion operations
	will typically be linear in the number of values in the array, but
	may be O(N*lg N) clearly in the worst case in some implementations.
	There are no favored positions within the array for performance;
	that is, it is not necessarily faster to access values with low
	indices, or to insert or delete values with high indices, or
	whatever.
	
	• 在数组中通过一个特定的索引获取值的时间复杂度最坏是`O(log n)`，但通常应该是`O(1)`。
	• 搜索一个未知索引的对象的时间复杂度最坏是`O(n (log n))`，但一般应该是`O(n)`。
	• 插入或者删除一个对象最坏的时间复杂度是`O(n (log n))`，但经常是`O(1)`


